{"version":3,"file":"static/js/json_venn.d5e7328c.chunk.js","mappings":"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","sources":["../node_modules/src/.internal/charts/venn/VennDefaultTheme.ts","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/blas1.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/nelderMead.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/linesearch.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/conjugateGradient.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/circleintersection.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/layout.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/bisect.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/diagram.js","../node_modules/src/.internal/charts/venn/Venn.ts"],"sourcesContent":["import { Theme } from \"../../core/Theme\";\r\nimport { p50, p100 } from \"../../core/util/Percent\";\r\nimport { ColorSet } from \"../../core/util/ColorSet\";\r\n\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport class VennDefaultTheme extends Theme {\r\n\tprotected setupDefaultRules() {\r\n\t\tsuper.setupDefaultRules();\r\n\t\tconst r = this.rule.bind(this);\r\n\r\n\t\tr(\"Venn\").setAll({\r\n\t\t\tlegendLabelText: \"{category}\",\r\n\t\t\tlegendValueText: \"{value}\",\r\n\t\t\tcolors: ColorSet.new(this._root, {}),\r\n\t\t\twidth: p100,\r\n\t\t\theight: p100\r\n\t\t});\r\n\r\n\r\n\t\tr(\"Label\", [\"venn\"]).setAll({\r\n\t\t\ttext: \"{category}\",\r\n\t\t\tpopulateText: true,\r\n\t\t\tcenterX: p50,\r\n\t\t\tcenterY: p50\r\n\t\t});\r\n\r\n\t}\r\n}\r\n","// need some basic operations on vectors, rather than adding a dependency,\n// just define here\nexport function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\nexport function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\nexport function dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n        ret += a[i] * b[i];\n    }\n    return ret;\n}\n\nexport function norm2(a)  {\n    return Math.sqrt(dot(a, a));\n}\n\nexport function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n        ret[i] = value[i] * c;\n    }\n}\n\nexport function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n        ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n}\n","import {dot, norm2, weightedSum} from \"./blas1\";\n\n/** minimizes a function using the downhill simplex method */\nexport function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n        chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n        psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n        sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n        maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n        var point = x0.slice();\n        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n        simplex[i+1] = point;\n        simplex[i+1].fx = f(point);\n        simplex[i+1].id = i+1;\n    }\n\n    function updateSimplex(value) {\n        for (var i = 0; i < value.length; i++) {\n            simplex[N][i] = value[i];\n        }\n        simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n        simplex.sort(sortOrder);\n\n        if (parameters.history) {\n            // copy the simplex (since later iterations will mutate) and\n            // sort it to have a consistent order between iterations\n            var sortedSimplex = simplex.map(function (x) {\n                var state = x.slice();\n                state.fx = x.fx;\n                state.id = x.id;\n                return state;\n            });\n            sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n            parameters.history.push({x: simplex[0].slice(),\n                                     fx: simplex[0].fx,\n                                     simplex: sortedSimplex});\n        }\n\n        maxDiff = 0;\n        for (i = 0; i < N; ++i) {\n            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n        }\n\n        if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n            (maxDiff < minTolerance)) {\n            break;\n        }\n\n        // compute the centroid of all but the worst point in the simplex\n        for (i = 0; i < N; ++i) {\n            centroid[i] = 0;\n            for (var j = 0; j < N; ++j) {\n                centroid[i] += simplex[j][i];\n            }\n            centroid[i] /= N;\n        }\n\n        // reflect the worst point past the centroid  and compute loss at reflected\n        // point\n        var worst = simplex[N];\n        weightedSum(reflected, 1+rho, centroid, -rho, worst);\n        reflected.fx = f(reflected);\n\n        // if the reflected point is the best seen, then possibly expand\n        if (reflected.fx < simplex[0].fx) {\n            weightedSum(expanded, 1+chi, centroid, -chi, worst);\n            expanded.fx = f(expanded);\n            if (expanded.fx < reflected.fx) {\n                updateSimplex(expanded);\n            }  else {\n                updateSimplex(reflected);\n            }\n        }\n\n        // if the reflected point is worse than the second worst, we need to\n        // contract\n        else if (reflected.fx >= simplex[N-1].fx) {\n            var shouldReduce = false;\n\n            if (reflected.fx > worst.fx) {\n                // do an inside contraction\n                weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < worst.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            } else {\n                // do an outside contraction\n                weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < reflected.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            }\n\n            if (shouldReduce) {\n                // if we don't contract here, we're done\n                if (sigma >= 1) break;\n\n                // do a reduction\n                for (i = 1; i < simplex.length; ++i) {\n                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                    simplex[i].fx = f(simplex[i]);\n                }\n            }\n        } else {\n            updateSimplex(reflected);\n        }\n    }\n\n    simplex.sort(sortOrder);\n    return {fx : simplex[0].fx,\n            x : simplex[0]};\n}\n","import {dot, weightedSum} from \"./blas1\";\n\n\n/// searches along line 'pk' for a point that satifies the wolfe conditions\n/// See 'Numerical Optimization' by Nocedal and Wright p59-60\n/// f : objective function\n/// pk : search direction\n/// current: object containing current gradient/loss\n/// next: output: contains next gradient/loss\n/// returns a: step size taken\nexport function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0, phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n        for (var iteration = 0; iteration < 16; ++iteration) {\n            a = (a_lo + a_high)/2;\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (phi >= phi_lo)) {\n                a_high = a;\n\n            } else  {\n                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                    return a;\n                }\n\n                if (phiPrime * (a_high - a_lo) >=0) {\n                    a_high = a_lo;\n                }\n\n                a_lo = a;\n                phi_lo = phi;\n            }\n        }\n\n        return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n            (iteration && (phi >= phi_old))) {\n            return zoom(a0, a, phi_old);\n        }\n\n        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n        }\n\n        if (phiPrime >= 0 ) {\n            return zoom(a, a0, phi);\n        }\n\n        phi_old = phi;\n        a0 = a;\n        a *= 2;\n    }\n\n    return a;\n}\n","import {dot, norm2, scale, weightedSum} from \"./blas1\";\nimport {wolfeLineSearch} from \"./linesearch\";\n\nexport function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        yk = initial.slice(),\n        pk, temp,\n        a = 1,\n        maxIterations;\n\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime,-1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n        a = wolfeLineSearch(f, pk, current, next, a);\n\n        // todo: history in wrong spot?\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        if (!a) {\n            // faiiled to find point that satifies wolfe conditions.\n            // reset direction for next iteration\n            scale(pk, current.fxprime, -1);\n\n        } else {\n            // update direction using Polak–Ribiere CG method\n            weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n            var delta_k = dot(current.fxprime, current.fxprime),\n                beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n            weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n            temp = current;\n            current = next;\n            next = temp;\n        }\n\n        if (norm2(current.fxprime) <= 1e-5) {\n            break;\n        }\n    }\n\n    if (params.history) {\n        params.history.push({x: current.x.slice(),\n                             fx: current.fx,\n                             fxprime: current.fxprime.slice(),\n                             alpha: a});\n    }\n\n    return current;\n}\n","var SMALL = 1e-10;\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nexport function intersectionArea(circles, stats) {\n    // get all the intersection points of the circles\n    var intersectionPoints = getIntersectionPoints(circles);\n\n    // filter out points that aren't included in all the circles\n    var innerPoints = intersectionPoints.filter(function (p) {\n        return containedInCircles(p, circles);\n    });\n\n    var arcArea = 0, polygonArea = 0, arcs = [], i;\n\n    // if we have intersection points that are within all the circles,\n    // then figure out the area contained by them\n    if (innerPoints.length > 1) {\n        // sort the points by angle from the center of the polygon, which lets\n        // us just iterate over points to get the edges\n        var center = getCenter(innerPoints);\n        for (i = 0; i < innerPoints.length; ++i ) {\n            var p = innerPoints[i];\n            p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n        }\n        innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\n        // iterate over all points, get arc between the points\n        // and update the areas\n        var p2 = innerPoints[innerPoints.length - 1];\n        for (i = 0; i < innerPoints.length; ++i) {\n            var p1 = innerPoints[i];\n\n            // polygon area updates easily ...\n            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n            // updating the arc area is a little more involved\n            var midPoint = {x : (p1.x + p2.x) / 2,\n                            y : (p1.y + p2.y) / 2},\n                arc = null;\n\n            for (var j = 0; j < p1.parentIndex.length; ++j) {\n                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n                    // figure out the angle halfway between the two points\n                    // on the current circle\n                    var circle = circles[p1.parentIndex[j]],\n                        a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                        a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n                    var angleDiff = (a2 - a1);\n                    if (angleDiff < 0) {\n                        angleDiff += 2*Math.PI;\n                    }\n\n                    // and use that angle to figure out the width of the\n                    // arc\n                    var a = a2 - angleDiff/2,\n                        width = distance(midPoint, {\n                            x : circle.x + circle.radius * Math.sin(a),\n                            y : circle.y + circle.radius * Math.cos(a)\n                        });\n\n                    // clamp the width to the largest is can actually be\n                    // (sometimes slightly overflows because of FP errors)\n                    if (width > circle.radius * 2) {\n                        width = circle.radius * 2;\n                    }\n\n                    // pick the circle whose arc has the smallest width\n                    if ((arc === null) || (arc.width > width)) {\n                        arc = { circle : circle,\n                                width : width,\n                                p1 : p1,\n                                p2 : p2};\n                    }\n                }\n            }\n\n            if (arc !== null) {\n                arcs.push(arc);\n                arcArea += circleArea(arc.circle.radius, arc.width);\n                p2 = p1;\n            }\n        }\n    } else {\n        // no intersection points, is either disjoint - or is completely\n        // overlapped. figure out which by examining the smallest circle\n        var smallest = circles[0];\n        for (i = 1; i < circles.length; ++i) {\n            if (circles[i].radius < smallest.radius) {\n                smallest = circles[i];\n            }\n        }\n\n        // make sure the smallest circle is completely contained in all\n        // the other circles\n        var disjoint = false;\n        for (i = 0; i < circles.length; ++i) {\n            if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n                disjoint = true;\n                break;\n            }\n        }\n\n        if (disjoint) {\n            arcArea = polygonArea = 0;\n\n        } else {\n            arcArea = smallest.radius * smallest.radius * Math.PI;\n            arcs.push({circle : smallest,\n                       p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n                       p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n                       width : smallest.radius * 2 });\n        }\n    }\n\n    polygonArea /= 2;\n    if (stats) {\n        stats.area = arcArea + polygonArea;\n        stats.arcArea = arcArea;\n        stats.polygonArea = polygonArea;\n        stats.arcs = arcs;\n        stats.innerPoints = innerPoints;\n        stats.intersectionPoints = intersectionPoints;\n    }\n\n    return arcArea + polygonArea;\n}\n\n/** returns whether a point is contained by all of a list of circles */\nexport function containedInCircles(point, circles) {\n    for (var i = 0; i < circles.length; ++i) {\n        if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n    var ret = [];\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var intersect = circleCircleIntersection(circles[i],\n                                                          circles[j]);\n            for (var k = 0; k < intersect.length; ++k) {\n                var p = intersect[k];\n                p.parentIndex = [i,j];\n                ret.push(p);\n            }\n        }\n    }\n    return ret;\n}\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nexport function circleArea(r, width) {\n    return r * r * Math.acos(1 - width/r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/** euclidean distance between two points */\nexport function distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                     (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nexport function circleOverlap(r1, r2, d) {\n    // no overlap\n    if (d >= r1 + r2) {\n        return 0;\n    }\n\n    // completely overlapped\n    if (d <= Math.abs(r1 - r2)) {\n        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n    }\n\n    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n    return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\nexport function circleCircleIntersection(p1, p2) {\n    var d = distance(p1, p2),\n        r1 = p1.radius,\n        r2 = p2.radius;\n\n    // if to far away, or self contained - can't be done\n    if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n        return [];\n    }\n\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n        h = Math.sqrt(r1 * r1 - a * a),\n        x0 = p1.x + a * (p2.x - p1.x) / d,\n        y0 = p1.y + a * (p2.y - p1.y) / d,\n        rx = -(p2.y - p1.y) * (h / d),\n        ry = -(p2.x - p1.x) * (h / d);\n\n    return [{x: x0 + rx, y : y0 - ry },\n            {x: x0 - rx, y : y0 + ry }];\n}\n\n/** Returns the center of a bunch of points */\nexport function getCenter(points) {\n    var center = {x: 0, y: 0};\n    for (var i =0; i < points.length; ++i ) {\n        center.x += points[i].x;\n        center.y += points[i].y;\n    }\n    center.x /= points.length;\n    center.y /= points.length;\n    return center;\n}\n","import {nelderMead, bisect, conjugateGradient, zeros, zerosM, norm2,\n        scale} from './fmin/index.js';\nimport {intersectionArea, circleOverlap, circleCircleIntersection, distance} from './circleintersection';\n\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\nexport function venn(areas, parameters) {\n    parameters = parameters || {};\n    parameters.maxIterations = parameters.maxIterations || 500;\n    var initialLayout = parameters.initialLayout || bestInitialLayout;\n    var loss = parameters.lossFunction || lossFunction;\n\n    // add in missing pairwise areas as having 0 size\n    areas = addMissingAreas(areas);\n\n    // initial layout is done greedily\n    var circles = initialLayout(areas, parameters);\n\n    // transform x/y coordinates to a vector to optimize\n    var initial = [], setids = [], setid;\n    for (setid in circles) {\n        if (circles.hasOwnProperty(setid)) {\n            initial.push(circles[setid].x);\n            initial.push(circles[setid].y);\n            setids.push(setid);\n        }\n    }\n\n    // optimize initial layout from our loss function\n    var totalFunctionCalls = 0;\n    var solution = nelderMead(\n        function(values) {\n            totalFunctionCalls += 1;\n            var current = {};\n            for (var i = 0; i < setids.length; ++i) {\n                var setid = setids[i];\n                current[setid] = {x: values[2 * i],\n                                  y: values[2 * i + 1],\n                                  radius : circles[setid].radius,\n                                 // size : circles[setid].size\n                                 };\n            }\n            return loss(current, areas);\n        },\n        initial,\n        parameters);\n\n    // transform solution vector back to x/y points\n    var positions = solution.x;\n    for (var i = 0; i < setids.length; ++i) {\n        setid = setids[i];\n        circles[setid].x = positions[2 * i];\n        circles[setid].y = positions[2 * i + 1];\n    }\n\n    return circles;\n}\n\nvar SMALL = 1e-10;\n\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\nexport function distanceFromIntersectArea(r1, r2, overlap) {\n    // handle complete overlapped circles\n    if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL) {\n        return Math.abs(r1 - r2);\n    }\n\n    return bisect(function(distance) {\n        return circleOverlap(r1, r2, distance) - overlap;\n    }, 0, r1 + r2);\n}\n\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\nfunction addMissingAreas(areas) {\n    areas = areas.slice();\n\n    // two circle intersections that aren't defined\n    var ids = [], pairs = {}, i, j, a, b;\n    for (i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            ids.push(area.sets[0]);\n        } else if (area.sets.length == 2) {\n            a = area.sets[0];\n            b = area.sets[1];\n            pairs[[a, b]] = true;\n            pairs[[b, a]] = true;\n        }\n    }\n    ids.sort(function(a, b) { return a > b; });\n\n    for (i = 0; i < ids.length; ++i) {\n        a = ids[i];\n        for (j = i + 1; j < ids.length; ++j) {\n            b = ids[j];\n            if (!([a, b] in pairs)) {\n                areas.push({'sets': [a, b],\n                            'size': 0});\n            }\n        }\n    }\n    return areas;\n}\n\n/// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\nexport function getDistanceMatrices(areas, sets, setids) {\n    // initialize an empty distance matrix between all the points\n    var distances = zerosM(sets.length, sets.length),\n        constraints = zerosM(sets.length, sets.length);\n\n    // compute required distances between all the sets such that\n    // the areas match\n    areas.filter(function(x) { return x.sets.length == 2; })\n        .map(function(current) {\n        var left = setids[current.sets[0]],\n            right = setids[current.sets[1]],\n            r1 = Math.sqrt(sets[left].size / Math.PI),\n            r2 = Math.sqrt(sets[right].size / Math.PI),\n            distance = distanceFromIntersectArea(r1, r2, current.size);\n\n        distances[left][right] = distances[right][left] = distance;\n\n        // also update constraints to indicate if its a subset or disjoint\n        // relationship\n        var c = 0;\n        if (current.size + 1e-10 >= Math.min(sets[left].size,\n                                             sets[right].size)) {\n            c = 1;\n        } else if (current.size <= 1e-10) {\n            c = -1;\n        }\n        constraints[left][right] = constraints[right][left] = c;\n    });\n\n    return {distances: distances, constraints: constraints};\n}\n\n/// computes the gradient and loss simulatenously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n    var loss = 0, i;\n    for (i = 0; i < fxprime.length; ++i) {\n        fxprime[i] = 0;\n    }\n\n    for (i = 0; i < distances.length; ++i) {\n        var xi = x[2 * i], yi = x[2 * i + 1];\n        for (var j = i + 1; j < distances.length; ++j) {\n            var xj = x[2 * j], yj = x[2 * j + 1],\n                dij = distances[i][j],\n                constraint = constraints[i][j];\n\n            var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n                distance = Math.sqrt(squaredDistance),\n                delta = squaredDistance - dij * dij;\n\n            if (((constraint > 0) && (distance <= dij)) ||\n                ((constraint < 0) && (distance >= dij))) {\n                continue;\n            }\n\n            loss += 2 * delta * delta;\n\n            fxprime[2*i]     += 4 * delta * (xi - xj);\n            fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\n            fxprime[2*j]     += 4 * delta * (xj - xi);\n            fxprime[2*j + 1] += 4 * delta * (yj - yi);\n        }\n    }\n    return loss;\n}\n\n/// takes the best working variant of either constrained MDS or greedy\nexport function bestInitialLayout(areas, params) {\n    var initial = greedyLayout(areas, params);\n    var loss = params.lossFunction || lossFunction;\n\n    // greedylayout is sufficient for all 2/3 circle cases. try out\n    // constrained MDS for higher order problems, take its output\n    // if it outperforms. (greedy is aesthetically better on 2/3 circles\n    // since it axis aligns)\n    if (areas.length >= 8) {\n        var constrained  = constrainedMDSLayout(areas, params),\n            constrainedLoss = loss(constrained, areas),\n            greedyLoss = loss(initial, areas);\n\n        if (constrainedLoss + 1e-8 < greedyLoss) {\n            initial = constrained;\n        }\n    }\n    return initial;\n}\n\n/// use the constrained MDS variant to generate an initial layout\nexport function constrainedMDSLayout(areas, params) {\n    params = params || {};\n    var restarts = params.restarts || 10;\n\n    // bidirectionally map sets to a rowid  (so we can create a matrix)\n    var sets = [], setids = {}, i;\n    for (i = 0; i < areas.length; ++i ) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            setids[area.sets[0]] = sets.length;\n            sets.push(area);\n        }\n    }\n\n    var matrices = getDistanceMatrices(areas, sets, setids),\n        distances = matrices.distances,\n        constraints = matrices.constraints;\n\n    // keep distances bounded, things get messed up otherwise.\n    // TODO: proper preconditioner?\n    var norm = norm2(distances.map(norm2))/(distances.length);\n    distances = distances.map(function (row) {\n        return row.map(function (value) { return value / norm; });});\n\n    var obj = function(x, fxprime) {\n        return constrainedMDSGradient(x, fxprime, distances, constraints);\n    };\n\n    var best, current;\n    for (i = 0; i < restarts; ++i) {\n        var initial = zeros(distances.length*2).map(Math.random);\n\n        current = conjugateGradient(obj, initial, params);\n        if (!best || (current.fx < best.fx)) {\n            best = current;\n        }\n    }\n    var positions = best.x;\n\n    // translate rows back to (x,y,radius) coordinates\n    var circles = {};\n    for (i = 0; i < sets.length; ++i) {\n        var set = sets[i];\n        circles[set.sets[0]] = {\n            x: positions[2*i] * norm,\n            y: positions[2*i + 1] * norm,\n            radius:  Math.sqrt(set.size / Math.PI)\n        };\n    }\n\n    if (params.history) {\n        for (i = 0; i < params.history.length; ++i) {\n            scale(params.history[i].x, norm);\n        }\n    }\n    return circles;\n}\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nexport function greedyLayout(areas, params) {\n    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n    // define a circle for each set\n    var circles = {}, setOverlaps = {}, set;\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            set = area.sets[0];\n            circles[set] = {x: 1e10, y: 1e10,\n                            rowid: circles.length,\n                            size: area.size,\n                            radius: Math.sqrt(area.size / Math.PI)};\n            setOverlaps[set] = [];\n        }\n    }\n    areas = areas.filter(function(a) { return a.sets.length == 2; });\n\n    // map each set to a list of all the other sets that overlap it\n    for (i = 0; i < areas.length; ++i) {\n        var current = areas[i];\n        var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n        var left = current.sets[0], right = current.sets[1];\n\n        // completely overlapped circles shouldn't be positioned early here\n        if (current.size + SMALL >= Math.min(circles[left].size,\n                                             circles[right].size)) {\n            weight = 0;\n        }\n\n        setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n        setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n    }\n\n    // get list of most overlapped sets\n    var mostOverlapped = [];\n    for (set in setOverlaps) {\n        if (setOverlaps.hasOwnProperty(set)) {\n            var size = 0;\n            for (i = 0; i < setOverlaps[set].length; ++i) {\n                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n            }\n\n            mostOverlapped.push({set: set, size:size});\n        }\n    }\n\n    // sort by size desc\n    function sortOrder(a,b) {\n        return b.size - a.size;\n    }\n    mostOverlapped.sort(sortOrder);\n\n    // keep track of what sets have been laid out\n    var positioned = {};\n    function isPositioned(element) {\n        return element.set in positioned;\n    }\n\n    // adds a point to the output\n    function positionSet(point, index) {\n        circles[index].x = point.x;\n        circles[index].y = point.y;\n        positioned[index] = true;\n    }\n\n    // add most overlapped set at (0,0)\n    positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\n    // get distances between all points. TODO, necessary?\n    // answer: probably not\n    // var distances = venn.getDistanceMatrices(circles, areas).distances;\n    for (i = 1; i < mostOverlapped.length; ++i) {\n        var setIndex = mostOverlapped[i].set,\n            overlap = setOverlaps[setIndex].filter(isPositioned);\n        set = circles[setIndex];\n        overlap.sort(sortOrder);\n\n        if (overlap.length === 0) {\n            // this shouldn't happen anymore with addMissingAreas\n            throw \"ERROR: missing pairwise overlap information\";\n        }\n\n        var points = [];\n        for (var j = 0; j < overlap.length; ++j) {\n            // get appropriate distance from most overlapped already added set\n            var p1 = circles[overlap[j].set],\n                d1 = distanceFromIntersectArea(set.radius, p1.radius,\n                                               overlap[j].size);\n\n            // sample positions at 90 degrees for maximum aesthetics\n            points.push({x : p1.x + d1, y : p1.y});\n            points.push({x : p1.x - d1, y : p1.y});\n            points.push({y : p1.y + d1, x : p1.x});\n            points.push({y : p1.y - d1, x : p1.x});\n\n            // if we have at least 2 overlaps, then figure out where the\n            // set should be positioned analytically and try those too\n            for (var k = j + 1; k < overlap.length; ++k) {\n                var p2 = circles[overlap[k].set],\n                    d2 = distanceFromIntersectArea(set.radius, p2.radius,\n                                                   overlap[k].size);\n\n                var extraPoints = circleCircleIntersection(\n                    { x: p1.x, y: p1.y, radius: d1},\n                    { x: p2.x, y: p2.y, radius: d2});\n\n                for (var l = 0; l < extraPoints.length; ++l) {\n                    points.push(extraPoints[l]);\n                }\n            }\n        }\n\n        // we have some candidate positions for the set, examine loss\n        // at each position to figure out where to put it at\n        var bestLoss = 1e50, bestPoint = points[0];\n        for (j = 0; j < points.length; ++j) {\n            circles[setIndex].x = points[j].x;\n            circles[setIndex].y = points[j].y;\n            var localLoss = loss(circles, areas);\n            if (localLoss < bestLoss) {\n                bestLoss = localLoss;\n                bestPoint = points[j];\n            }\n        }\n\n        positionSet(bestPoint, setIndex);\n    }\n\n    return circles;\n}\n\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\nexport function lossFunction(sets, overlaps) {\n    var output = 0;\n\n    function getCircles(indices) {\n        return indices.map(function(i) { return sets[i]; });\n    }\n\n    for (var i = 0; i < overlaps.length; ++i) {\n        var area = overlaps[i], overlap;\n        if (area.sets.length == 1) {\n            continue;\n        } else if (area.sets.length == 2) {\n            var left = sets[area.sets[0]],\n                right = sets[area.sets[1]];\n            overlap = circleOverlap(left.radius, right.radius,\n                                    distance(left, right));\n        } else {\n            overlap = intersectionArea(getCircles(area.sets));\n        }\n\n        var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n        output += weight * (overlap - area.size) * (overlap - area.size);\n    }\n\n    return output;\n}\n\n// orientates a bunch of circles to point in orientation\nfunction orientateCircles(circles, orientation, orientationOrder) {\n    if (orientationOrder === null) {\n        circles.sort(function (a, b) { return b.radius - a.radius; });\n    } else {\n        circles.sort(orientationOrder);\n    }\n\n    var i;\n    // shift circles so largest circle is at (0, 0)\n    if (circles.length > 0) {\n        var largestX = circles[0].x,\n            largestY = circles[0].y;\n\n        for (i = 0; i < circles.length; ++i) {\n            circles[i].x -= largestX;\n            circles[i].y -= largestY;\n        }\n    }\n\n    if (circles.length == 2) {\n        // if the second circle is a subset of the first, arrange so that\n        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n        var dist = distance(circles[0], circles[1]);\n        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n            circles[1].y = circles[0].y;\n        }\n    }\n\n    // rotate circles so that second largest is at an angle of 'orientation'\n    // from largest\n    if (circles.length > 1) {\n        var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n            c = Math.cos(rotation),\n            s = Math.sin(rotation), x, y;\n\n        for (i = 0; i < circles.length; ++i) {\n            x = circles[i].x;\n            y = circles[i].y;\n            circles[i].x = c * x - s * y;\n            circles[i].y = s * x + c * y;\n        }\n    }\n\n    // mirror solution if third solution is above plane specified by\n    // first two circles\n    if (circles.length > 2) {\n        var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n        while (angle < 0) { angle += 2* Math.PI; }\n        while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n        if (angle > Math.PI) {\n            var slope = circles[1].y / (1e-10 + circles[1].x);\n            for (i = 0; i < circles.length; ++i) {\n                var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n                circles[i].x = 2 * d - circles[i].x;\n                circles[i].y = 2 * d * slope - circles[i].y;\n            }\n        }\n    }\n}\n\nexport function disjointCluster(circles) {\n    // union-find clustering to get disjoint sets\n    circles.map(function(circle) { circle.parent = circle; });\n\n    // path compression step in union find\n    function find(circle) {\n        if (circle.parent !== circle) {\n            circle.parent = find(circle.parent);\n        }\n        return circle.parent;\n    }\n\n    function union(x, y) {\n        var xRoot = find(x), yRoot = find(y);\n        xRoot.parent = yRoot;\n    }\n\n    // get the union of all overlapping sets\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var maxDistance = circles[i].radius + circles[j].radius;\n            if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n                union(circles[j], circles[i]);\n            }\n        }\n    }\n\n    // find all the disjoint clusters and group them together\n    var disjointClusters = {}, setid;\n    for (i = 0; i < circles.length; ++i) {\n        setid = find(circles[i]).parent.setid;\n        if (!(setid in disjointClusters)) {\n            disjointClusters[setid] = [];\n        }\n        disjointClusters[setid].push(circles[i]);\n    }\n\n    // cleanup bookkeeping\n    circles.map(function(circle) { delete circle.parent; });\n\n    // return in more usable form\n    var ret = [];\n    for (setid in disjointClusters) {\n        if (disjointClusters.hasOwnProperty(setid)) {\n            ret.push(disjointClusters[setid]);\n        }\n    }\n    return ret;\n}\n\nfunction getBoundingBox(circles) {\n    var minMax = function(d) {\n        var hi = Math.max.apply(null, circles.map(\n                                function(c) { return c[d] + c.radius; } )),\n            lo = Math.min.apply(null, circles.map(\n                                function(c) { return c[d] - c.radius;} ));\n        return {max:hi, min:lo};\n    };\n\n    return {xRange: minMax('x'), yRange: minMax('y')};\n}\n\nexport function normalizeSolution(solution, orientation, orientationOrder) {\n    if (orientation === null){\n        orientation = Math.PI/2;\n    }\n\n    // work with a list instead of a dictionary, and take a copy so we\n    // don't mutate input\n    var circles = [], i, setid;\n    for (setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            var previous = solution[setid];\n            circles.push({x: previous.x,\n                          y: previous.y,\n                          radius: previous.radius,\n                          setid: setid});\n        }\n    }\n\n    // get all the disjoint clusters\n    var clusters = disjointCluster(circles);\n\n    // orientate all disjoint sets, get sizes\n    for (i = 0; i < clusters.length; ++i) {\n        orientateCircles(clusters[i], orientation, orientationOrder);\n        var bounds = getBoundingBox(clusters[i]);\n        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n        clusters[i].bounds = bounds;\n    }\n    clusters.sort(function(a, b) { return b.size - a.size; });\n\n    // orientate the largest at 0,0, and get the bounds\n    circles = clusters[0];\n    var returnBounds = circles.bounds;\n\n    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\n    function addCluster(cluster, right, bottom) {\n        if (!cluster) return;\n\n        var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\n        if (right) {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n        } else {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n                        (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n            if (centreing < 0) xOffset += centreing;\n        }\n\n        if (bottom) {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n        } else {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n                        (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n            if (centreing < 0) yOffset += centreing;\n        }\n\n        for (var j = 0; j < cluster.length; ++j) {\n            cluster[j].x += xOffset;\n            cluster[j].y += yOffset;\n            circles.push(cluster[j]);\n        }\n    }\n\n    var index = 1;\n    while (index < clusters.length) {\n        addCluster(clusters[index], true, false);\n        addCluster(clusters[index+1], false, true);\n        addCluster(clusters[index+2], true, true);\n        index += 3;\n\n        // have one cluster (in top left). lay out next three relative\n        // to it in a grid\n        returnBounds = getBoundingBox(circles);\n    }\n\n    // convert back to solution form\n    var ret = {};\n    for (i = 0; i < circles.length; ++i) {\n        ret[circles[i].setid] = circles[i];\n    }\n    return ret;\n}\n\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\nexport function scaleSolution(solution, width, height, padding) {\n    var circles = [], setids = [];\n    for (var setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            setids.push(setid);\n            circles.push(solution[setid]);\n        }\n    }\n\n    width -= 2*padding;\n    height -= 2*padding;\n\n    var bounds = getBoundingBox(circles),\n        xRange = bounds.xRange,\n        yRange = bounds.yRange;\n\n    if ((xRange.max == xRange.min) ||\n        (yRange.max == yRange.min)) {\n        console.log(\"not scaling solution: zero size detected\");\n        return solution;\n    }\n\n    var xScaling = width  / (xRange.max - xRange.min),\n        yScaling = height / (yRange.max - yRange.min),\n        scaling = Math.min(yScaling, xScaling),\n\n        // while we're at it, center the diagram too\n        xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n        yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n    var scaled = {};\n    for (var i = 0; i < circles.length; ++i) {\n        var circle = circles[i];\n        scaled[setids[i]] = {\n            radius: scaling * circle.radius,\n            x: padding + xOffset + (circle.x - xRange.min) * scaling,\n            y: padding + yOffset + (circle.y - yRange.min) * scaling,\n        };\n    }\n\n    return scaled;\n}\n","/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nexport function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n        throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n        delta /= 2;\n        var mid = a + delta,\n            fMid = f(mid);\n\n        if (fMid * fA >= 0) {\n            a = mid;\n        }\n\n        if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n            return mid;\n        }\n    }\n    return a + delta;\n}\n","import {select, selectAll} from \"d3-selection\";\nimport {transition} from \"d3-transition\";\n\nimport {venn, lossFunction, normalizeSolution, scaleSolution} from \"./layout\";\nimport {intersectionArea, distance, getCenter} from \"./circleintersection\";\nimport {nelderMead} from \"./fmin/index.js\";\n\n/*global console:true*/\n\nexport function VennDiagram() {\n    var width = 600,\n        height = 350,\n        padding = 15,\n        duration = 1000,\n        orientation = Math.PI / 2,\n        normalize = true,\n        wrap = true,\n        styled = true,\n        fontSize = null,\n        orientationOrder = null,\n\n        // mimic the behaviour of d3.scale.category10 from the previous\n        // version of d3\n        colourMap = {},\n\n        // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n        // since we can support older versions of d3 as long as we don't force this,\n        // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n        colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n        colourIndex = 0,\n        colours = function(key) {\n            if (key in colourMap) {\n                return colourMap[key];\n            }\n            var ret = colourMap[key] = colourScheme[colourIndex];\n            colourIndex += 1;\n            if (colourIndex >= colourScheme.length) {\n                colourIndex = 0;\n            }\n            return ret;\n        },\n        layoutFunction = venn,\n        loss = lossFunction;\n\n\n    function chart(selection) {\n        var data = selection.datum();\n\n        // handle 0-sized sets by removing from input\n        var toremove = {};\n        data.forEach(function(datum) {\n            if ((datum.size == 0) && datum.sets.length == 1) {\n                toremove[datum.sets[0]] = 1;\n            }\n        });\n        data = data.filter(function(datum) {\n            return !datum.sets.some(function(set) { return set in toremove; });\n        });\n\n        var circles = {};\n        var textCentres = {};\n\n        if (data.length > 0) {\n            var solution = layoutFunction(data, {lossFunction: loss});\n\n            if (normalize) {\n                solution = normalizeSolution(solution,\n                                            orientation,\n                                            orientationOrder);\n            }\n\n            circles = scaleSolution(solution, width, height, padding);\n            textCentres = computeTextCentres(circles, data);\n        }\n\n        // Figure out the current label for each set. These can change\n        // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n        var labels = {};\n        data.forEach(function(datum) {\n            if (datum.label) {\n                labels[datum.sets] = datum.label;\n            }\n        });\n\n        function label(d) {\n            if (d.sets in labels) {\n                return labels[d.sets];\n            }\n            if (d.sets.length == 1) {\n                return '' + d.sets[0];\n            }\n        }\n\n        // create svg if not already existing\n        selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\n        var svg = selection.select(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        // to properly transition intersection areas, we need the\n        // previous circles locations. load from elements\n        var previous = {}, hasPrevious = false;\n        svg.selectAll(\".venn-area path\").each(function (d) {\n            var path = select(this).attr(\"d\");\n            if ((d.sets.length == 1) && path) {\n                hasPrevious = true;\n                previous[d.sets[0]] = circleFromPath(path);\n            }\n        });\n\n        // interpolate intersection area paths between previous and\n        // current paths\n        var pathTween = function(d) {\n            return function(t) {\n                var c = d.sets.map(function(set) {\n                    var start = previous[set], end = circles[set];\n                    if (!start) {\n                        start = {x : width/2, y : height/2, radius : 1};\n                    }\n                    if (!end) {\n                        end = {x : width/2, y : height/2, radius : 1};\n                    }\n                    return {'x' : start.x * (1 - t) + end.x * t,\n                            'y' : start.y * (1 - t) + end.y * t,\n                            'radius' : start.radius * (1 - t) + end.radius * t};\n                });\n                return intersectionAreaPath(c);\n            };\n        };\n\n        // update data, joining on the set ids\n        var nodes = svg.selectAll(\".venn-area\")\n            .data(data, function(d) { return d.sets; });\n\n        // create new nodes\n        var enter = nodes.enter()\n            .append('g')\n            .attr(\"class\", function(d) {\n                return \"venn-area venn-\" +\n                    (d.sets.length == 1 ? \"circle\" : \"intersection\");\n            })\n            .attr(\"data-venn-sets\", function(d) {\n                return d.sets.join(\"_\");\n            });\n\n        var enterPath = enter.append(\"path\"),\n            enterText = enter.append(\"text\")\n            .attr(\"class\", \"label\")\n            .text(function (d) { return label(d); } )\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"dy\", \".35em\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n\n        // apply minimal style if wanted\n        if (styled) {\n            enterPath.style(\"fill-opacity\", \"0\")\n                .filter(function (d) { return d.sets.length == 1; } )\n                .style(\"fill\", function(d) { return colours(d.sets); })\n                .style(\"fill-opacity\", \".25\");\n\n            enterText\n                .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(d.sets) : \"#444\"; });\n        }\n\n        // update existing, using pathTween if necessary\n        var update = selection;\n        if (hasPrevious) {\n            update = selection.transition(\"venn\").duration(duration);\n            update.selectAll(\"path\")\n                .attrTween(\"d\", pathTween);\n        } else {\n            update.selectAll(\"path\")\n                .attr(\"d\", function(d) {\n                    return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n                });\n        }\n\n        var updateText = update.selectAll(\"text\")\n            .filter(function (d) { return d.sets in textCentres; })\n            .text(function (d) { return label(d); } )\n            .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n            .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\n        if (wrap) {\n            if (hasPrevious) {\n                // d3 4.0 uses 'on' for events on transitions,\n                // but d3 3.0 used 'each' instead. switch appropiately\n                if ('on' in updateText) {\n                    updateText.on(\"end\", wrapText(circles, label));\n                } else {\n                    updateText.each(\"end\", wrapText(circles, label));\n                }\n            } else {\n                updateText.each(wrapText(circles, label));\n            }\n        }\n\n        // remove old\n        var exit = nodes.exit().transition('venn').duration(duration).remove();\n        exit.selectAll(\"path\")\n            .attrTween(\"d\", pathTween);\n\n        var exitText = exit.selectAll(\"text\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n        // if we've been passed a fontSize explicitly, use it to\n        // transition\n        if (fontSize !== null) {\n            enterText.style(\"font-size\", \"0px\");\n            updateText.style(\"font-size\", fontSize);\n            exitText.style(\"font-size\", \"0px\");\n        }\n\n\n        return {'circles': circles,\n                'textCentres': textCentres,\n                'nodes': nodes,\n                'enter': enter,\n                'update': update,\n                'exit': exit};\n    }\n\n    chart.wrap = function(_) {\n        if (!arguments.length) return wrap;\n        wrap = _;\n        return chart;\n    };\n\n    chart.width = function(_) {\n        if (!arguments.length) return width;\n        width = _;\n        return chart;\n    };\n\n    chart.height = function(_) {\n        if (!arguments.length) return height;\n        height = _;\n        return chart;\n    };\n\n    chart.padding = function(_) {\n        if (!arguments.length) return padding;\n        padding = _;\n        return chart;\n    };\n\n    chart.colours = function(_) {\n        if (!arguments.length) return colours;\n        colours = _;\n        return chart;\n    };\n\n    chart.fontSize = function(_) {\n        if (!arguments.length) return fontSize;\n        fontSize = _;\n        return chart;\n    };\n\n    chart.duration = function(_) {\n        if (!arguments.length) return duration;\n        duration = _;\n        return chart;\n    };\n\n    chart.layoutFunction = function(_) {\n        if (!arguments.length) return layoutFunction;\n        layoutFunction = _;\n        return chart;\n    };\n\n    chart.normalize = function(_) {\n        if (!arguments.length) return normalize;\n        normalize = _;\n        return chart;\n    };\n\n    chart.styled = function(_) {\n        if (!arguments.length) return styled;\n        styled = _;\n        return chart;\n    };\n\n    chart.orientation = function(_) {\n        if (!arguments.length) return orientation;\n        orientation = _;\n        return chart;\n    };\n\n    chart.orientationOrder = function(_) {\n        if (!arguments.length) return orientationOrder;\n        orientationOrder = _;\n        return chart;\n    };\n\n    chart.lossFunction = function(_) {\n      if (!arguments.length) return loss;\n      loss = _;\n      return chart;\n    };\n\n    return chart;\n}\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nexport function wrapText(circles, labeller) {\n    return function() {\n        var text = select(this),\n            data = text.datum(),\n            width = circles[data.sets[0]].radius || 50,\n            label = labeller(data) || '';\n\n            var words = label.split(/\\s+/).reverse(),\n            maxLines = 3,\n            minChars = (label.length + words.length) / maxLines,\n            word = words.pop(),\n            line = [word],\n            joined,\n            lineNumber = 0,\n            lineHeight = 1.1, // ems\n            tspan = text.text(null).append(\"tspan\").text(word);\n\n        while (true) {\n            word = words.pop();\n            if (!word) break;\n            line.push(word);\n            joined = line.join(\" \");\n            tspan.text(joined);\n            if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n                line.pop();\n                tspan.text(line.join(\" \"));\n                line = [word];\n                tspan = text.append(\"tspan\").text(word);\n                lineNumber++;\n            }\n        }\n\n        var initial = 0.35 - lineNumber * lineHeight / 2,\n            x = text.attr(\"x\"),\n            y = text.attr(\"y\");\n\n        text.selectAll(\"tspan\")\n            .attr(\"x\", x)\n            .attr(\"y\", y)\n            .attr(\"dy\", function(d, i) {\n                 return (initial + i * lineHeight) + \"em\";\n            });\n    };\n}\n\nfunction circleMargin(current, interior, exterior) {\n    var margin = interior[0].radius - distance(interior[0], current), i, m;\n    for (i = 1; i < interior.length; ++i) {\n        m = interior[i].radius - distance(interior[i], current);\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        m = distance(exterior[i], current) - exterior[i].radius;\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n    return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n    // get an initial estimate by sampling around the interior circles\n    // and taking the point with the biggest margin\n    var points = [], i;\n    for (i = 0; i < interior.length; ++i) {\n        var c = interior[i];\n        points.push({x: c.x, y: c.y});\n        points.push({x: c.x + c.radius/2, y: c.y});\n        points.push({x: c.x - c.radius/2, y: c.y});\n        points.push({x: c.x, y: c.y + c.radius/2});\n        points.push({x: c.x, y: c.y - c.radius/2});\n    }\n    var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n    for (i = 1; i < points.length; ++i) {\n        var m = circleMargin(points[i], interior, exterior);\n        if (m >= margin) {\n            initial = points[i];\n            margin = m;\n        }\n    }\n\n    // maximize the margin numerically\n    var solution = nelderMead(\n                function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n                [initial.x, initial.y],\n                {maxIterations:500, minErrorDelta:1e-10}).x;\n    var ret = {x: solution[0], y: solution[1]};\n\n    // check solution, fallback as needed (happens if fully overlapped\n    // etc)\n    var valid = true;\n    for (i = 0; i < interior.length; ++i) {\n        if (distance(ret, interior[i]) > interior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        if (distance(ret, exterior[i]) < exterior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    if (!valid) {\n        if (interior.length == 1) {\n            ret = {x: interior[0].x, y: interior[0].y};\n        } else {\n            var areaStats = {};\n            intersectionArea(interior, areaStats);\n\n            if (areaStats.arcs.length === 0) {\n                ret = {'x': 0, 'y': -1000, disjoint:true};\n\n            } else if (areaStats.arcs.length == 1) {\n                ret = {'x': areaStats.arcs[0].circle.x,\n                       'y': areaStats.arcs[0].circle.y};\n\n            } else if (exterior.length) {\n                // try again without other circles\n                ret = computeTextCentre(interior, []);\n\n            } else {\n                // take average of all the points in the intersection\n                // polygon. this should basically never happen\n                // and has some issues:\n                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n                ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n            }\n        }\n    }\n\n    return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n    var ret = {}, circleids = [];\n    for (var circleid in circles) {\n        circleids.push(circleid);\n        ret[circleid] = [];\n    }\n    for (var i  = 0; i < circleids.length; i++) {\n        var a = circles[circleids[i]];\n        for (var j = i + 1; j < circleids.length; ++j) {\n            var b = circles[circleids[j]],\n                d = distance(a, b);\n\n            if (d + b.radius <= a.radius + 1e-10) {\n                ret[circleids[j]].push(circleids[i]);\n\n            } else if (d + a.radius <= b.radius + 1e-10) {\n                ret[circleids[i]].push(circleids[j]);\n            }\n        }\n    }\n    return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n    var ret = {}, overlapped = getOverlappingCircles(circles);\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i].sets, areaids = {}, exclude = {};\n        for (var j = 0; j < area.length; ++j) {\n            areaids[area[j]] = true;\n            var overlaps = overlapped[area[j]];\n            // keep track of any circles that overlap this area,\n            // and don't consider for purposes of computing the text\n            // centre\n            for (var k = 0; k < overlaps.length; ++k) {\n                exclude[overlaps[k]] = true;\n            }\n        }\n\n        var interior = [], exterior = [];\n        for (var setid in circles) {\n            if (setid in areaids) {\n                interior.push(circles[setid]);\n            } else if (!(setid in exclude)) {\n                exterior.push(circles[setid]);\n            }\n        }\n        var centre = computeTextCentre(interior, exterior);\n        ret[area] = centre;\n        if (centre.disjoint && (areas[i].size > 0)) {\n            console.log(\"WARNING: area \" + area + \" not represented on screen\");\n        }\n    }\n    return  ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nexport function sortAreas(div, relativeTo) {\n\n    // figure out sets that are completly overlapped by relativeTo\n    var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n    var exclude = {};\n    for (var i = 0; i < relativeTo.sets.length; ++i) {\n        var check = relativeTo.sets[i];\n        for (var setid in overlaps) {\n            var overlap = overlaps[setid];\n            for (var j = 0; j < overlap.length; ++j) {\n                if (overlap[j] == check) {\n                    exclude[setid] = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    // checks that all sets are in exclude;\n    function shouldExclude(sets) {\n        for (var i = 0; i < sets.length; ++i) {\n            if (!(sets[i] in exclude)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // need to sort div's so that Z order is correct\n    div.selectAll(\"g\").sort(function (a, b) {\n        // highest order set intersections first\n        if (a.sets.length != b.sets.length) {\n            return a.sets.length - b.sets.length;\n        }\n\n        if (a == relativeTo) {\n            return shouldExclude(b.sets) ? -1 : 1;\n        }\n        if (b == relativeTo) {\n            return shouldExclude(a.sets) ? 1 : -1;\n        }\n\n        // finally by size\n        return b.size - a.size;\n    });\n}\n\nexport function circlePath(x, y, r) {\n    var ret = [];\n    ret.push(\"\\nM\", x, y);\n    ret.push(\"\\nm\", -r, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n    return ret.join(\" \");\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n    var tokens = path.split(' ');\n    return {'x' : parseFloat(tokens[1]),\n            'y' : parseFloat(tokens[2]),\n            'radius' : -parseFloat(tokens[4])\n            };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n    var stats = {};\n    intersectionArea(circles, stats);\n    var arcs = stats.arcs;\n\n    if (arcs.length === 0) {\n        return \"M 0 0\";\n\n    } else if (arcs.length == 1) {\n        var circle = arcs[0].circle;\n        return circlePath(circle.x, circle.y, circle.radius);\n\n    } else {\n        // draw path around arcs\n        var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n        for (var i = 0; i < arcs.length; ++i) {\n            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n            ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n                     arc.p1.x, arc.p1.y);\n        }\n        return ret.join(\" \");\n    }\n}\n","import type { DataItem } from \"../../core/render/Component\";\n\nimport { VennDefaultTheme } from \"./VennDefaultTheme\";\nimport { Series, ISeriesSettings, ISeriesDataItem, ISeriesPrivate } from \"../../core/render/Series\";\nimport { Template } from \"../../core/util/Template\";\nimport { Graphics, visualSettings } from \"../../core/render/Graphics\";\nimport { Container } from \"../../core/render/Container\";\nimport { Label } from \"../../core/render/Label\";\nimport { ListTemplate } from \"../../core/util/List\";\nimport type { ILegendDataItem } from \"../../core/render/Legend\";\nimport type { Color } from \"../../core/util/Color\";\nimport type { ColorSet } from \"../../core/util/ColorSet\";\n\nimport * as $utils from \"../../core/util/Utils\";\nimport * as $array from \"../../core/util/Array\";\nimport * as $type from \"../../core/util/Type\";\nimport * as venn from \"./vennjs/index.js\";\n\nexport interface IVennDataItem extends ISeriesDataItem {\n\n\t/**\n\t * Array of categories that this data item is an intersection for.\n\t */\n\tintersections: Array<string>;\n\n\t/**\n\t * Category.\n\t */\n\tcategory: string;\n\n\t/**\n\t * Slice visaul element.\n\t */\n\tslice: Graphics;\n\n\t/**\n\t * Slice label.\n\t */\n\tlabel: Label;\n\n\t/**\n\t * A related legend data item.\n\t */\n\tlegendDataItem: DataItem<ILegendDataItem>;\n\n\t/**\n\t * Fill color used for the slice and related elements, e.g. legend marker.\n\t */\n\tfill: Color;\n\n}\n\nexport interface IVennSettings extends ISeriesSettings {\n\n\t/**\n\t * A field in data that holds array of categories that overlap.\n\t */\n\tintersectionsField?: string;\n\n\t/**\n\t * A [[ColorSet]] to use when asigning colors for slices.\n\t */\n\tcolors?: ColorSet;\n\n\t/**\n\t * A field in data that holds category names.\n\t */\n\tcategoryField?: string;\n\n\t/**\n\t * A field that holds color for slice fill.\n\t */\n\tfillField?: string;\n\n}\n\nexport interface IVennPrivate extends ISeriesPrivate {\n}\n\n/**\n * Creates a Venn diagram.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/venn/} for more info\n * @important\n */\nexport class Venn extends Series {\n\n\tpublic static className: string = \"Venn\";\n\tpublic static classNames: Array<string> = Series.classNames.concat([Venn.className]);\n\n\tdeclare public _settings: IVennSettings;\n\tdeclare public _privateSettings: IVennPrivate;\n\tdeclare public _dataItemSettings: IVennDataItem;\n\n\tprotected _sets: string = \"\";\n\n\t/**\n\t * A [[Container]] that holds all slices (circles and intersections).\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly slicesContainer = this.children.push(Container.new(this._root, {}));\n\n\t/**\n\t * A [[Container]] that holds all labels.\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly labelsContainer = this.children.push(Container.new(this._root, {}));\n\n\t/**\n\t * A [[Graphics]] element that is used to show the shape of the hovered slice\n\t * or intersection.\n\t *\n\t * @default Graphics.new()\n\t */\n\tpublic readonly hoverGraphics = this.slicesContainer.children.push(Graphics.new(this._root, { position: \"absolute\", isMeasured: false }))\n\n\tprotected _hovered?: Graphics;\n\n\tprotected _afterNew() {\n\t\tthis._defaultThemes.push(VennDefaultTheme.new(this._root));\n\t\tthis.fields.push(\"intersections\", \"category\", \"fill\");\n\t\tsuper._afterNew();\n\t}\n\n\n\t/**\n\t * A [[ListTemplate]] of all slices in series.\n\t *\n\t * `slices.template` can also be used to configure slices.\n\t */\n\tpublic readonly slices: ListTemplate<Graphics> = this._makeSlices();\n\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeSlice(dataItem: DataItem<this[\"_dataItemSettings\"]>): Graphics {\n\t\tconst slice = this.slicesContainer.children.push(this.slices.make());\n\t\tslice.events.on(\"pointerover\", (e) => {\n\t\t\tthis._hovered = e.target;\n\t\t\tthis._updateHover();\n\t\t})\n\n\t\tslice.events.on(\"pointerout\", () => {\n\t\t\tthis._hovered = undefined;\n\t\t\tthis.hoverGraphics.hide();\n\t\t})\n\n\t\tslice.on(\"fill\", () => {\n\t\t\tthis.updateLegendMarker(dataItem);\n\t\t})\n\n\t\tslice.on(\"stroke\", () => {\n\t\t\tthis.updateLegendMarker(dataItem);\n\t\t})\n\n\t\tslice._setDataItem(dataItem);\n\t\tdataItem.set(\"slice\", slice);\n\t\tthis.slices.push(slice);\n\n\t\treturn slice;\n\t}\n\n\tprotected _updateHover() {\n\t\tif (this._hovered) {\n\t\t\tconst hoverGraphics = this.hoverGraphics;\n\t\t\thoverGraphics.set(\"svgPath\", this._hovered.get(\"svgPath\"));\n\t\t\thoverGraphics.show();\n\t\t\thoverGraphics.toFront();\n\t\t}\n\t}\n\n\t/**\n\t * A [[ListTemplate]] of all slice labels in series.\n\t *\n\t * `labels.template` can also be used to configure slice labels.\n\t */\n\tpublic readonly labels: ListTemplate<Label> = this._makeLabels();\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeLabel(dataItem: DataItem<this[\"_dataItemSettings\"]>): Label {\n\t\tconst label = this.labelsContainer.children.push(this.labels.make());\n\t\tlabel._setDataItem(dataItem);\n\t\tdataItem.set(\"label\", label);\n\t\tthis.labels.push(label);\n\t\treturn label;\n\t}\n\n\n\tprotected _makeSlices(): ListTemplate<Graphics> {\n\t\treturn new ListTemplate(\n\t\t\tTemplate.new({}),\n\t\t\t() => Graphics._new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(this.slices.template.get(\"themeTags\", []), [\"venn\", \"series\"])\n\t\t\t}, [this.slices.template]),\n\t\t);\n\t}\n\n\tprotected _makeLabels(): ListTemplate<Label> {\n\t\treturn new ListTemplate(\n\t\t\tTemplate.new({}),\n\t\t\t() => Label._new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(this.labels.template.get(\"themeTags\", []), [\"venn\", \"series\"])\n\t\t\t}, [this.labels.template]),\n\t\t);\n\t}\n\n\n\tprotected processDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tsuper.processDataItem(dataItem);\n\n\n\t\tif (dataItem.get(\"fill\") == null) {\n\t\t\tlet colors = this.get(\"colors\");\n\t\t\tif (colors) {\n\t\t\t\tdataItem.setRaw(\"fill\", colors.next());\n\t\t\t}\n\t\t}\n\n\t\tthis.makeSlice(dataItem);\n\t\tthis.makeLabel(dataItem);\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tif (this._valuesDirty || this._sizeDirty) {\n\t\t\tconst sets: any[] = [];\n\n\t\t\t// prepare data for venn\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tconst set: any = {};\n\t\t\t\tconst intersections = dataItem.get(\"intersections\");\n\t\t\t\tif (intersections) {\n\t\t\t\t\tset.sets = intersections;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tset.sets = [dataItem.get(\"category\")];\n\t\t\t\t}\n\t\t\t\tset.size = dataItem.get(\"valueWorking\");\n\n\t\t\t\tif (set.size > 0) {\n\t\t\t\t\tsets.push(set);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tconst newSets = sets.toString();\n\n\t\t\tthis._sets = newSets;\n\n\t\t\tif (sets.length > 0) {\n\t\t\t\tlet vennData = venn.venn(sets);\n\t\t\t\tvennData = venn.normalizeSolution(vennData, null, null);\n\t\t\t\tvennData = venn.scaleSolution(vennData, this.innerWidth(), this.innerHeight(), 0);\n\n\t\t\t\tconst circles: any = {};\n\t\t\t\tfor (let name in vennData) {\n\t\t\t\t\tlet item = vennData[name];\n\t\t\t\t\tlet r = item.radius;\n\n\t\t\t\t\tconst dataItem = this.getDataItemByCategory(name);\n\t\t\t\t\tif (dataItem) {\n\t\t\t\t\t\tconst slice = dataItem.get(\"slice\");\n\t\t\t\t\t\tconst color = dataItem.get(\"fill\");\n\t\t\t\t\t\tslice._setDefault(\"fill\", color);\n\t\t\t\t\t\tslice._setDefault(\"stroke\", color);\n\n\t\t\t\t\t\tthis.updateLegendMarker(dataItem);\n\n\t\t\t\t\t\tslice.set(\"svgPath\", \"M\" + item.x + \",\" + item.y + \" m -\" + r + \", 0 a \" + r + \",\" + r + \" 0 1,1 \" + r * 2 + \",0 a \" + r + \",\" + r + \" 0 1,1 -\" + r * 2 + \",0\");\n\t\t\t\t\t\tcircles[name] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tlet centers: any = venn.computeTextCentres(circles, sets);\n\n\n\t\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\t\tlet name = dataItem.get(\"category\");\n\t\t\t\t\tlet center = centers[name];\n\t\t\t\t\tconst intersections = dataItem.get(\"intersections\");\n\t\t\t\t\tif (intersections) {\n\t\t\t\t\t\tname = intersections.toString();\n\t\t\t\t\t\tcenter = centers[name];\n\t\t\t\t\t\tif (center) {\n\t\t\t\t\t\t\tlet set = intersections;\n\t\t\t\t\t\t\tlet cc = [];\n\n\t\t\t\t\t\t\tfor (let s = 0; s < set.length; s++) {\n\t\t\t\t\t\t\t\tcc.push(circles[set[s]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet intersectionPath = venn.intersectionAreaPath(cc)\n\t\t\t\t\t\t\tlet slice = dataItem.get(\"slice\");\n\n\t\t\t\t\t\t\tconst color = dataItem.get(\"fill\");\n\t\t\t\t\t\t\tslice._setDefault(\"fill\", color);\n\t\t\t\t\t\t\tslice._setDefault(\"stroke\", color);\n\n\t\t\t\t\t\t\tslice.setAll({ svgPath: intersectionPath });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\tlet label = dataItem.get(\"label\");\n\t\t\t\t\t\tlabel.setAll({ x: center.x, y: center.y });\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateLegendValue(dataItem);\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis._updateHover();\n\t\t}\n\t}\n\n\t/**\n\t * Looks up and returns a data item by its category.\n\t *\n\t * @param   category  Category\n\t * @return      Data item\n\t */\n\tpublic getDataItemByCategory(id: string): DataItem<this[\"_dataItemSettings\"]> | undefined {\n\t\treturn $array.find(this.dataItems, (dataItem: any) => {\n\t\t\treturn dataItem.get(\"category\") == id;\n\t\t})\n\t}\n\n\n\t/**\n\t * Shows series's data item.\n\t *\n\t * @param   dataItem  Data item\n\t * @param   duration  Animation duration in milliseconds\n\t * @return            Promise\n\t */\n\tpublic async showDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, duration?: number): Promise<void> {\n\t\tconst promises = [super.showDataItem(dataItem, duration)];\n\t\tif (!$type.isNumber(duration)) {\n\t\t\tduration = this.get(\"stateAnimationDuration\", 0);\n\t\t}\n\n\t\tconst easing = this.get(\"stateAnimationEasing\");\n\n\t\tlet value = dataItem.get(\"value\");\n\n\t\tconst animation = dataItem.animate({ key: \"valueWorking\", to: value, duration: duration, easing: easing });\n\t\tif (animation) {\n\t\t\tpromises.push(animation.waitForStop());\n\t\t}\n\n\t\tconst label = dataItem.get(\"label\");\n\t\tif (label) {\n\t\t\tpromises.push(label.show(duration));\n\t\t}\n\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tpromises.push(slice.show(duration));\n\t\t}\n\n\n\t\tconst intersections = dataItem.get(\"intersections\");\n\t\tif (intersections) {\n\t\t\t$array.each(intersections, (cat) => {\n\t\t\t\tconst di = this.getDataItemByCategory(cat);\n\t\t\t\tif (di && di.isHidden()) {\n\t\t\t\t\tthis.showDataItem(di, duration);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tif (!intersections) {\n\t\t\tconst category = dataItem.get(\"category\");\n\n\t\t\t$array.each(this.dataItems, (di) => {\n\t\t\t\tconst intersections = di.get(\"intersections\");\n\t\t\t\tif (di != dataItem && intersections) {\n\t\t\t\t\tlet allVisible = true;\n\t\t\t\t\t$array.each(intersections, (cat) => {\n\t\t\t\t\t\tconst dii = this.getDataItemByCategory(cat);\n\t\t\t\t\t\tif (dii && dii.isHidden()) {\n\t\t\t\t\t\t\tallVisible = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tif (allVisible && intersections.indexOf(category) != -1) {\n\t\t\t\t\t\tif (di.isHidden()) {\n\t\t\t\t\t\t\tthis.showDataItem(di, duration);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * Hides series's data item.\n\t *\n\t * @param   dataItem  Data item\n\t * @param   duration  Animation duration in milliseconds\n\t * @return            Promise\n\t */\n\tpublic async hideDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, duration?: number): Promise<void> {\n\t\tconst promises = [super.hideDataItem(dataItem, duration)];\n\t\tconst hiddenState = this.states.create(\"hidden\", {})\n\n\t\tif (!$type.isNumber(duration)) {\n\t\t\tduration = hiddenState.get(\"stateAnimationDuration\", this.get(\"stateAnimationDuration\", 0));\n\t\t}\n\n\t\tconst easing = hiddenState.get(\"stateAnimationEasing\", this.get(\"stateAnimationEasing\"));\n\n\t\tconst animation = dataItem.animate({ key: \"valueWorking\", to: 0, duration: duration, easing: easing });\n\t\tif (animation) {\n\t\t\tpromises.push(animation.waitForStop());\n\t\t}\n\n\t\tconst label = dataItem.get(\"label\");\n\t\tif (label) {\n\t\t\tpromises.push(label.hide(duration));\n\t\t}\n\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tpromises.push(slice.hide(duration));\n\t\t\tslice.hideTooltip();\n\t\t}\n\n\t\tif (!dataItem.get(\"intersections\")) {\n\t\t\t$array.each(this.dataItems, (di) => {\n\t\t\t\tconst intersections = di.get(\"intersections\");\n\t\t\t\tif (di != dataItem && intersections) {\n\t\t\t\t\tif (intersections.indexOf(dataItem.get(\"category\")) != -1) {\n\t\t\t\t\t\tthis.hideDataItem(di, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic disposeDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tsuper.disposeDataItem(dataItem);\n\t\tlet label = dataItem.get(\"label\");\n\t\tif (label) {\n\t\t\tthis.labels.removeValue(label);\n\t\t\tlabel.dispose();\n\t\t}\n\n\t\tlet slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tthis.slices.removeValue(slice);\n\t\t\tslice.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic updateLegendMarker(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tconst slice = dataItem.get(\"slice\");\n\n\t\tif (slice) {\n\t\t\tconst legendDataItem = dataItem.get(\"legendDataItem\");\n\t\t\tif (legendDataItem) {\n\t\t\t\tconst markerRectangle = legendDataItem.get(\"markerRectangle\");\n\n\t\t\t\t$array.each(visualSettings, (setting: any) => {\n\t\t\t\t\tmarkerRectangle.set(setting, slice.get(setting));\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Triggers hover on a series data item.\n\t *\n\t * @since 5.0.7\n\t * @param  dataItem  Target data item\n\t */\n\tpublic hoverDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice && !slice.isHidden()) {\n\t\t\tslice.hover();\n\t\t}\n\t}\n\n\t/**\n\t * Triggers un-hover on a series data item.\n\t *\n\t * @since 5.0.7\n\t * @param  dataItem  Target data item\n\t */\n\tpublic unhoverDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tslice.unhover();\n\t\t}\n\t}\n}\n"],"names":["VennDefaultTheme","_Theme","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","_get","_getPrototypeOf","prototype","call","r","this","rule","bind","setAll","legendLabelText","legendValueText","colors","ColorSet","new","_root","width","p100","height","text","populateText","centerX","p50","centerY","Theme","zeros","x","Array","i","zerosM","y","map","dot","a","b","ret","length","norm2","Math","sqrt","scale","c","weightedSum","w1","v1","w2","v2","j","nelderMead","f","x0","parameters","maxDiff","maxIterations","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","N","simplex","fx","id","point","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","history","sortedSimplex","state","push","max","abs","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","temp","yk","alpha","delta_k","SMALL","intersectionArea","circles","stats","intersectionPoints","intersect","circleCircleIntersection","k","p","parentIndex","getIntersectionPoints","innerPoints","filter","distance","radius","containedInCircles","arcArea","polygonArea","arcs","center","getCenter","angle","atan2","p2","p1","midPoint","arc","indexOf","circle","a1","a2","angleDiff","PI","sin","cos","circleArea","smallest","disjoint","area","acos","circleOverlap","r1","r2","d","min","h","y0","rx","ry","points","distanceFromIntersectArea","overlap","tolerance","fA","fB","delta","mid","fMid","bisect","bestInitialLayout","areas","set","loss","lossFunction","setOverlaps","sets","rowid","size","weight","hasOwnProperty","left","right","mostOverlapped","positioned","isPositioned","element","positionSet","index","setIndex","d1","d2","extraPoints","l","bestLoss","bestPoint","localLoss","greedyLayout","constrained","restarts","setids","matrices","distances","constraints","getDistanceMatrices","norm","row","best","obj","xi","yi","xj","yj","dij","constraint","squaredDistance","constrainedMDSGradient","random","positions","constrainedMDSLayout","overlaps","output","orientateCircles","orientation","orientationOrder","largestX","largestY","rotation","s","slope","getBoundingBox","minMax","xRange","yRange","normalizeSolution","solution","setid","previous","clusters","find","parent","union","xRoot","yRoot","maxDistance","disjointClusters","disjointCluster","bounds","returnBounds","spacing","addCluster","cluster","bottom","xOffset","yOffset","centreing","circleMargin","interior","exterior","m","margin","computeTextCentre","valid","areaStats","getOverlappingCircles","circleids","circleid","computeTextCentres","overlapped","areaids","exclude","centre","console","log","intersectionAreaPath","join","circlePath","wide","Venn","_Series","_super2","_this","Object","defineProperty","_assertThisInitialized","children","Container","slicesContainer","Graphics","position","isMeasured","_makeSlices","_makeLabels","_defaultThemes","fields","dataItem","_this2","slices","make","events","on","e","_hovered","target","_updateHover","hoverGraphics","hide","updateLegendMarker","_setDataItem","get","show","toFront","label","labelsContainer","labels","_this3","ListTemplate","Template","_new","themeTags","$utils","template","_this4","Label","setRaw","makeSlice","makeLabel","_this5","_valuesDirty","_sizeDirty","$array","dataItems","intersections","newSets","toString","_sets","vennData","initialLayout","ids","pairs","addMissingAreas","values","venn","padding","xScaling","yScaling","scaling","scaled","innerWidth","innerHeight","name","item","getDataItemByCategory","color","_setDefault","centers","cc","intersectionPath","svgPath","updateLegendValue","duration","_this6","promises","showDataItem","$type","easing","animation","animate","to","waitForStop","cat","di","_this7","isHidden","category","allVisible","dii","_context","Promise","all","stop","_callee","_this8","hideDataItem","hiddenState","states","create","hideTooltip","_this9","_context2","_callee2","removeValue","dispose","legendDataItem","markerRectangle","visualSettings","setting","hover","unhover","Series","classNames","concat","className"],"sourceRoot":""}